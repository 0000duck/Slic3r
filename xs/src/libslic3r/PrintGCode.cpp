#ifndef SLIC3RXS
#include "PrintGCode.hpp"
#include "PrintConfig.hpp"

#include <ctime>
#include <iostream>

namespace Slic3r {
void
PrintGCode::output()
{
    auto& gcodegen {this->_gcodegen};
    auto& fh {this->fh};
    auto& print {this->_print};
    const auto& config {this->config};
    const auto extruders {print.extruders()};

    // Write information about the generator.
    time_t rawtime; tm * timeinfo;
    time(&rawtime);
    timeinfo = localtime(&rawtime);
    
    fh << "; generated by Slic3r " << SLIC3R_VERSION << " on ";
    fh << asctime(timeinfo) << "\n";
    fh << "; Git Commit: " << BUILD_COMMIT << "\n\n";

    // Writes notes (content of all Settings tabs -> Notes)
    fh << gcodegen.notes();

    // Write some terse information on the slicing parameters.
    auto& first_object {*(this->objects.at(0))};
    auto layer_height {first_object.config.layer_height.getFloat()};

    for (auto* region : print.regions) {
        {
            auto flow {region->flow(frExternalPerimeter, layer_height, false, false, -1, first_object)};
            auto vol_speed {flow.mm3_per_mm() * region->config.get_abs_value("external_perimeter_speed")};
            if (config.max_volumetric_speed.getInt() > 0)
                vol_speed = std::min(vol_speed, config.max_volumetric_speed.getFloat());
            fh << "; external perimeters extrusion width = ";
            fh << std::fixed << std::setprecision(2) << flow.width << "mm ";
            fh << "(" << vol_speed << "mm^3/s)\n";
        }
        {
            auto flow {region->flow(frPerimeter, layer_height, false, false, -1, first_object)};
            auto vol_speed {flow.mm3_per_mm() * region->config.get_abs_value("perimeter_speed")};
            if (config.max_volumetric_speed.getInt() > 0)
                vol_speed = std::min(vol_speed, config.max_volumetric_speed.getFloat());
            fh << "; perimeters extrusion width = ";
            fh << std::fixed << std::setprecision(2) << flow.width << "mm ";
            fh << "(" << vol_speed << "mm^3/s)\n";
        }
        {
            auto flow {region->flow(frInfill, layer_height, false, false, -1, first_object)};
            auto vol_speed {flow.mm3_per_mm() * region->config.get_abs_value("infill_speed")};
            if (config.max_volumetric_speed.getInt() > 0)
                vol_speed = std::min(vol_speed, config.max_volumetric_speed.getFloat());
            fh << "; infill extrusion width = ";
            fh << std::fixed << std::setprecision(2) << flow.width << "mm ";
            fh << "(" << vol_speed << "mm^3/s)\n";
        }
        {
            auto flow {region->flow(frSolidInfill, layer_height, false, false, -1, first_object)};
            auto vol_speed {flow.mm3_per_mm() * region->config.get_abs_value("solid_infill_speed")};
            if (config.max_volumetric_speed.getInt() > 0)
                vol_speed = std::min(vol_speed, config.max_volumetric_speed.getFloat());
            fh << "; solid infill extrusion width = ";
            fh << std::fixed << std::setprecision(2) << flow.width << "mm ";
            fh << "(" << vol_speed << "mm^3/s)\n";
        }
        {
            auto flow {region->flow(frTopSolidInfill, layer_height, false, false, -1, first_object)};
            auto vol_speed {flow.mm3_per_mm() * region->config.get_abs_value("top_solid_infill_speed")};
            if (config.max_volumetric_speed.getInt() > 0)
                vol_speed = std::min(vol_speed, config.max_volumetric_speed.getFloat());
            fh << "; top solid infill extrusion width = ";
            fh << std::fixed << std::setprecision(2) << flow.width << "mm ";
            fh << "(" << vol_speed << "mm^3/s)\n";
        }
        if (print.has_support_material()) {
            auto flow {first_object._support_material_flow()};
            auto vol_speed {flow.mm3_per_mm() * first_object.config.get_abs_value("support_material_speed")};
            if (config.max_volumetric_speed.getInt() > 0)
                vol_speed = std::min(vol_speed, config.max_volumetric_speed.getFloat());
            fh << "; support material extrusion width = ";
            fh << std::fixed << std::setprecision(2) << flow.width << "mm ";
            fh << "(" << vol_speed << "mm^3/s)\n";
        }
        if (print.config.first_layer_extrusion_width.getFloat() > 0) {
            auto flow {region->flow(frPerimeter, layer_height, false, false, -1, first_object)};
//          auto vol_speed {flow.mm3_per_mm() * print.config.get_abs_value("first_layer_speed")};
//          if (config.max_volumetric_speed.getInt() > 0)
//              vol_speed = std::min(vol_speed, config.max_volumetric_speed.getFloat());
            fh << "; first layer extrusion width = ";
            fh << std::fixed << std::setprecision(2) << flow.width << "mm ";
//          fh << "(" << vol_speed << "mm^3/s)\n";
        }

        fh << std::endl;
    }
    // Prepare the helper object for replacing placeholders in custom G-Code and output filename
    print.placeholder_parser.update_timestamp();

    // GCode sets this automatically when change_layer() is called, but needed for skirt/brim as well
    gcodegen.first_layer = true;

    // disable fan
    if (config.cooling.getBool() && config.disable_fan_first_layers.getInt() > 0) {
        fh << gcodegen.writer.set_fan(0,1) << "\n";
    }

    // set bed temperature
    auto bed_temp_regex { std::regex("M(?:190|140)", std::regex_constants::icase)};
    auto ex_temp_regex { std::regex("M(?:109|104)", std::regex_constants::icase)};
    auto temp{config.first_layer_bed_temperature.getFloat()};
    if (config.has_heatbed && temp > 0 && std::regex_search(config.start_gcode.getString(), bed_temp_regex)) {
        fh << gcodegen.writer.set_bed_temperature(temp, 1);
    }
    
    // Set extruder(s) temperature before and after start gcode.
    auto include_start_extruder_temp {!std::regex_search(config.start_gcode.getString(), ex_temp_regex)};
    for(const auto& start_gcode : config.start_filament_gcode.values) {
        include_start_extruder_temp = include_start_extruder_temp && !std::regex_search(start_gcode, ex_temp_regex);
    }

    auto include_end_extruder_temp {!std::regex_search(config.end_gcode.getString(), ex_temp_regex)};
    for(const auto& end_gcode : config.end_filament_gcode.values) {
        include_end_extruder_temp = include_end_extruder_temp && !std::regex_search(end_gcode, ex_temp_regex);
    }

    if (include_start_extruder_temp) this->_print_first_layer_temperature(0);

    // Apply gcode math to start and end gcode
    fh << apply_math(gcodegen.placeholder_parser->process(config.start_gcode.value));

    for(const auto& start_gcode : config.start_filament_gcode.values) {
        fh << apply_math(gcodegen.placeholder_parser->process(start_gcode));
    }
    
    if (include_start_extruder_temp) this->_print_first_layer_temperature(1);


    // Set other general things (preamble)
    fh << gcodegen.preamble();

    // initialize motion planner for object-to-object travel moves
    if (config.avoid_crossing_perimeters.getBool()) {

        // compute the offsetted convex hull for each object and repeat it for each copy
        Polygons islands_p {};
        for (auto object : this->objects) {
            Polygons polygons {};
            // Add polygons that aren't just thin walls.
            for (auto layer : object->layers) {
                const auto& slice {ExPolygons(layer->slices)};
                std::for_each(slice.cbegin(), slice.cend(), [&polygons] (const ExPolygon& a) { polygons.emplace_back(a.contour); });
            }
            
            if (polygons.size() == 0) continue;

            for (auto copy : object->_shifted_copies) {
                Polygons copy_islands_p {polygons};
                std::for_each(copy_islands_p.begin(), copy_islands_p.end(), [copy] (Polygon& obj) { obj.translate(copy); });
                islands_p.insert(islands_p.cend(), copy_islands_p.begin(), copy_islands_p.end());
            }
        }
        
        gcodegen.avoid_crossing_perimeters.init_external_mp(union_ex(islands_p));
    }

    // Calculate wiping points if needed.
    if (config.ooze_prevention && extruders.size() > 1) {
    }

    // Set initial extruder only after custom start gcode
    fh << gcodegen.set_extruder(*(extruders.begin()));

    // Do all objects for each layer.

    if (config.complete_objects) {
    } else {
        // order objects using a nearest neighbor search
        std::vector<Points::size_type> obj_idx {};
        Points p;
        for (const auto obj : this->objects ) 
            p.emplace_back(obj->_shifted_copies.at(0));

        std::vector<size_t> z(100); // preallocate with 100 layers
        std::map<size_t, LayerPtrs> layers {};
        for (size_t idx = 0U; idx < print.objects.size(); ++idx) {
            const auto& object {*(objects.at(idx))};
            // sort layers by Z into buckets
            for (auto* layer : object.layers) {
                if (layers.count(layer->print_z) == 0) { // initialize bucket if empty
                    layers[layer->print_z] = LayerPtrs();
                    z.emplace_back(layer->print_z);
                }
                layers[layer->print_z].emplace_back(layer);
            }
            for (Layer* layer : object.support_layers) { // don't use auto here to not have to cast later
                if (layers.count(layer->print_z) == 0) { // initialize bucket if empty
                    layers[layer->print_z] = LayerPtrs();
                    z.emplace_back(layer->print_z);
                }
                layers[layer->print_z].emplace_back(layer);
            }
        }

        // pass the comparator to leave no doubt.
        std::sort(z.begin(), z.end(),  std::less<size_t>());
        
        //  call process_layers in the order given by obj_idx
        for (const auto& print_z : z) {
            for (const auto idx : obj_idx) {
                for (const auto* layer : layers.at(print_z)) {
                    this->process_layer(idx, layer, layer->object()->_shifted_copies);
                }
            }
        }
        
        this->flush_filters();
    }

    // Write end commands to file.
    fh << gcodegen.retract(); // TODO: process this retract through PressureRegulator in order to discharge fully

    // set bed temperature
    if (config.has_heatbed && temp > 0 && std::regex_search(config.end_gcode.getString(), bed_temp_regex)) {
        fh << gcodegen.writer.set_bed_temperature(0, 0);
    }

    // Get filament stats
    print.filament_stats.clear();
    print.total_used_filament = 0.0;
    print.total_extruded_volume = 0.0;
    print.total_weight = 0.0;
    print.total_cost = 0.0;

    
    for (auto extruder_pair : gcodegen.writer.extruders) {
        const auto& extruder {extruder_pair.second};
        auto used_material {extruder.used_filament()};
        auto extruded_volume {extruder.extruded_volume()};
        auto material_weight {extruded_volume * extruder.filament_density() / 1000.0};
        auto material_cost { material_weight * (extruder.filament_cost() / 1000.0)};

        print.filament_stats[extruder.id] = used_material;

        fh << "; material used = ";
        fh << std::fixed << std::setprecision(2) << used_material << "mm ";
        fh << "(" << std::fixed << std::setprecision(2) 
           << extruded_volume / 1000.0 
           << used_material << "cm3)\n";

        if (material_weight > 0) {
            print.total_weight += material_weight;
            fh << "; material used = " 
               << std::fixed << std::setprecision(2) << material_weight << "g\n";
            if (material_cost > 0) {
                print.total_cost += material_cost;
                fh << "; material cost = " 
                   << std::fixed << std::setprecision(2) << material_weight << "g\n";
            }
        }
        print.total_used_filament += used_material;
        print.total_extruded_volume += extruded_volume;
    }
    fh << "; total filament cost = " 
       << std::fixed << std::setprecision(2) << print.total_cost << "\n";

    // Append full config
    fh << std::endl;

    // print config
    _print_config(print.config);
    _print_config(print.default_object_config);
    _print_config(print.default_region_config);
}

std::string 
PrintGCode::filter(const std::string& in, bool wait) 
{
    return in;
}

void
PrintGCode::process_layer(size_t idx, const Layer* layer, const Points& copies)
{
    std::string gcode {""};
    auto& gcodegen {this->_gcodegen};

    const auto& obj {*(layer->object())};
    gcodegen.config.apply(obj.config, true);



    fh << this->filter(gcode);
}

void
PrintGCode::_print_first_layer_temperature(bool wait) 
{
    auto& gcodegen {this->_gcodegen};
    auto& fh {this->fh};
    const auto& print {this->_print};
    const auto& config {this->config};
    const auto extruders {print.extruders()};

    for (auto& t : extruders) {
        auto temp { config.first_layer_temperature.get_at(t) };
        if (config.ooze_prevention.value) temp += config.standby_temperature_delta.value;
        if (temp > 0) fh << gcodegen.writer.set_temperature(temp, wait, t);
    }
}

void 
PrintGCode::_print_config(const ConfigBase& config)
{
    for (const auto& key : config.keys()) {
        // skip if a shortcut option
        //            if (std::find(print_config_def.cbegin(), print_config_def.cend(), key) > 0) continue;
        fh << "; " << key << " = " << config.serialize(key) << "\n";
    }
}

PrintGCode::PrintGCode(Slic3r::Print& print, std::ostream& _fh) : 
        _print(print), 
        config(print.config), 
        _gcodegen(Slic3r::GCode()),
        objects(print.objects),
        fh(_fh),
        _cooling_buffer(Slic3r::CoolingBuffer(this->_gcodegen)),
        _spiral_vase(Slic3r::SpiralVase(this->config))
{ 
    size_t layer_count {0};
    if (config.complete_objects) {
        layer_count = std::accumulate(objects.cbegin(), objects.cend(), layer_count, [](const size_t& ret, const PrintObject* obj){ return ret + (obj->copies().size() * obj->total_layer_count()); });
    } else {
        layer_count = std::accumulate(objects.cbegin(), objects.cend(), layer_count, [](const size_t& ret, const PrintObject* obj){ return ret + obj->total_layer_count(); });
    }
    _gcodegen.placeholder_parser = &(print.placeholder_parser); // initialize 
    _gcodegen.layer_count = layer_count;
    _gcodegen.enable_cooling_markers = true;
    _gcodegen.apply_print_config(config);

    auto extruders {print.extruders()}; 
    _gcodegen.set_extruders(extruders.cbegin(), extruders.cend());
}

} // namespace Slic3r
#endif //SLIC3RXS
