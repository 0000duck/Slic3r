#ifndef SLIC3RXS
#include "PrintGCode.hpp"

#include <ctime>
#include <iostream>

namespace Slic3r {
void
PrintGCode::output()
{
    auto& gcodegen {this->_gcodegen};
    auto& fh {this->fh};
    auto& print {this->_print};
    const auto& config {this->config};

    // Write information about the generator.
    time_t rawtime; tm * timeinfo;
    time(&rawtime);
    timeinfo = localtime(&rawtime);
    
    fh << "; generated by Slic3r " << SLIC3R_VERSION << " on ";
    fh << asctime(timeinfo) << "\n";
    fh << "; Git Commit: " << BUILD_COMMIT << "\n\n";

    // Writes notes (content of all Settings tabs -> Notes)
    fh << gcodegen.notes();

    // Write some terse information on the slicing parameters.
    auto& first_object {*(this->objects.at(0))};
    auto layer_height {first_object.config.layer_height.getFloat()};

    for (auto* region : print.regions) {
        {
            auto flow {region->flow(frExternalPerimeter, layer_height, false, false, -1, first_object)};
            auto vol_speed {flow.mm3_per_mm() * region->config.get_abs_value("external_perimeter_speed")};
            if (config.max_volumetric_speed.getInt() > 0)
                vol_speed = std::min(vol_speed, config.max_volumetric_speed.getFloat());
            fh << "; external perimeters extrusion width = ";
            fh << std::fixed << std::setprecision(2) << flow.width << "mm ";
            fh << "(" << vol_speed << "mm^3/s)\n";
        }
        {
            auto flow {region->flow(frPerimeter, layer_height, false, false, -1, first_object)};
            auto vol_speed {flow.mm3_per_mm() * region->config.get_abs_value("perimeter_speed")};
            if (config.max_volumetric_speed.getInt() > 0)
                vol_speed = std::min(vol_speed, config.max_volumetric_speed.getFloat());
            fh << "; perimeters extrusion width = ";
            fh << std::fixed << std::setprecision(2) << flow.width << "mm ";
            fh << "(" << vol_speed << "mm^3/s)\n";
        }
        {
            auto flow {region->flow(frInfill, layer_height, false, false, -1, first_object)};
            auto vol_speed {flow.mm3_per_mm() * region->config.get_abs_value("infill_speed")};
            if (config.max_volumetric_speed.getInt() > 0)
                vol_speed = std::min(vol_speed, config.max_volumetric_speed.getFloat());
            fh << "; infill extrusion width = ";
            fh << std::fixed << std::setprecision(2) << flow.width << "mm ";
            fh << "(" << vol_speed << "mm^3/s)\n";
        }
        {
            auto flow {region->flow(frSolidInfill, layer_height, false, false, -1, first_object)};
            auto vol_speed {flow.mm3_per_mm() * region->config.get_abs_value("solid_infill_speed")};
            if (config.max_volumetric_speed.getInt() > 0)
                vol_speed = std::min(vol_speed, config.max_volumetric_speed.getFloat());
            fh << "; solid infill extrusion width = ";
            fh << std::fixed << std::setprecision(2) << flow.width << "mm ";
            fh << "(" << vol_speed << "mm^3/s)\n";
        }
        {
            auto flow {region->flow(frTopSolidInfill, layer_height, false, false, -1, first_object)};
            auto vol_speed {flow.mm3_per_mm() * region->config.get_abs_value("top_solid_infill_speed")};
            if (config.max_volumetric_speed.getInt() > 0)
                vol_speed = std::min(vol_speed, config.max_volumetric_speed.getFloat());
            fh << "; top solid infill extrusion width = ";
            fh << std::fixed << std::setprecision(2) << flow.width << "mm ";
            fh << "(" << vol_speed << "mm^3/s)\n";
        }
        if (print.has_support_material()) {
            auto flow {first_object._support_material_flow()};
            auto vol_speed {flow.mm3_per_mm() * first_object.config.get_abs_value("support_material_speed")};
            if (config.max_volumetric_speed.getInt() > 0)
                vol_speed = std::min(vol_speed, config.max_volumetric_speed.getFloat());
            fh << "; support material extrusion width = ";
            fh << std::fixed << std::setprecision(2) << flow.width << "mm ";
            fh << "(" << vol_speed << "mm^3/s)\n";
        }
        if (print.config.first_layer_extrusion_width.getFloat() > 0) {
            auto flow {region->flow(frPerimeter, layer_height, false, false, -1, first_object)};
//          auto vol_speed {flow.mm3_per_mm() * print.config.get_abs_value("first_layer_speed")};
//          if (config.max_volumetric_speed.getInt() > 0)
//              vol_speed = std::min(vol_speed, config.max_volumetric_speed.getFloat());
            fh << "; first layer extrusion width = ";
            fh << std::fixed << std::setprecision(2) << flow.width << "mm ";
//          fh << "(" << vol_speed << "mm^3/s)\n";
        }

        fh << std::endl;
    }
    // Prepare the helper object for replacing placeholders in custom G-Code and output filename
    print.placeholder_parser.update_timestamp();

    // GCode sets this automatically when change_layer() is called, but needed for skirt/brim as well
    gcodegen.first_layer = true;

    // disable fan
    if (config.cooling.getBool() && config.disable_fan_first_layers.getInt() > 0) {
        fh << gcodegen.writer.set_fan(0,1) << "\n";
    }

    // set bed temperature
    auto bed_temp_regex { std::regex("M(?:190|140)", std::regex_constants::icase)};
    auto ex_temp_regex { std::regex("M(?:109|104)", std::regex_constants::icase)};
    auto temp{config.first_layer_bed_temperature.getFloat()};
    if (config.has_heatbed.getBool() && temp > 0 && std::regex_search(config.start_gcode.getString(), bed_temp_regex)) {
        fh << gcodegen.writer.set_bed_temperature(temp, 1);
    }
    
    // Set extruder(s) temperature before and after start gcode.
    auto include_start_extruder_temp {!std::regex_search(config.start_gcode.getString(), ex_temp_regex)};
    for(const auto& start_gcode : config.start_filament_gcode.values) {
        include_start_extruder_temp = include_start_extruder_temp && !std::regex_search(start_gcode, ex_temp_regex);
    }

    auto include_end_extruder_temp {!std::regex_search(config.end_gcode.getString(), ex_temp_regex)};
    for(const auto& end_gcode : config.end_filament_gcode.values) {
        include_end_extruder_temp = include_end_extruder_temp && !std::regex_search(end_gcode, ex_temp_regex);
    }

    if (include_start_extruder_temp) this->_print_first_layer_temperature(0);

    // Apply gcode math to start and end gcode
    fh << apply_math(gcodegen.placeholder_parser->process(config.start_gcode.value));

    for(const auto& start_gcode : config.start_filament_gcode.values) {
        fh << apply_math(gcodegen.placeholder_parser->process(start_gcode));
    }
    
    if (include_start_extruder_temp) this->_print_first_layer_temperature(1);


    // Set other general things (preamble)
    fh << gcodegen.preamble();

    // initialize motion planner for object-to-object travel moves
    if (config.avoid_crossing_perimeters.getBool()) {

        // compute the offsetted convex hull for each object and repeat it for each copy
        Polygons islands_p {};
        for (auto object : this->objects) {
            Polygons polygons {};
            // Add polygons that aren't just thin walls.
            for (auto layer : object->layers) {
                const auto& slice {ExPolygons(layer->slices)};
                std::for_each(slice.cbegin(), slice.cend(), [&polygons] (const ExPolygon& a) { polygons.emplace_back(a.contour); });
            }
            
            if (polygons.size() == 0) continue;

            for (auto copy : object->_shifted_copies) {
                Polygons copy_islands_p {polygons};
                std::for_each(copy_islands_p.begin(), copy_islands_p.end(), [copy] (Polygon& obj) { obj.translate(copy); });
                islands_p.insert(islands_p.cend(), copy_islands_p.begin(), copy_islands_p.end());
            }
        }
        
        gcodegen.avoid_crossing_perimeters.init_external_mp(union_ex(islands_p));
    }

    // Calculate wiping points if needed.
    //
    
    // Set initial extruder only after custom start gcode

    // Do all objects for each layer.

    if (config.complete_objects.getBool()) {
    } else {
    }

    // Write end commands to file.

    // set bed temperature

    // Get filament stats

    // Append full config
}

std::string 
PrintGCode::filter(const std::string& in, bool wait) 
{
    return in;
}

void
PrintGCode::_print_first_layer_temperature(bool wait) 
{
    auto& gcodegen {this->_gcodegen};
    auto& fh {this->fh};
    const auto& print {this->_print};
    const auto& config {this->config};

    for (auto& t : print.extruders()) {
        auto temp { config.first_layer_temperature.get_at(t) };
        if (config.ooze_prevention.value) temp += config.standby_temperature_delta.value;
        if (temp > 0) fh << gcodegen.writer.set_temperature(temp, wait, t);
    }
}

PrintGCode::PrintGCode(Slic3r::Print& print, std::ostream& _fh) : 
        _print(print), 
        config(print.config), 
        _gcodegen(Slic3r::GCode()),
        objects(print.objects),
        fh(_fh),
        _cooling_buffer(Slic3r::CoolingBuffer(this->_gcodegen)),
        _spiral_vase(Slic3r::SpiralVase(this->config))
{ 
    size_t layer_count {0};
    if (config.complete_objects) {
        layer_count = std::accumulate(objects.cbegin(), objects.cend(), layer_count, [](const size_t& ret, const PrintObject* obj){ return ret + (obj->copies().size() * obj->total_layer_count()); });
    } else {
        layer_count = std::accumulate(objects.cbegin(), objects.cend(), layer_count, [](const size_t& ret, const PrintObject* obj){ return ret + obj->total_layer_count(); });
    }
    _gcodegen.placeholder_parser = &(print.placeholder_parser); // initialize 
    _gcodegen.layer_count = layer_count;
    _gcodegen.enable_cooling_markers = true;
    _gcodegen.apply_print_config(config);
    std::cerr << "Setting " << print.extruders().size() << "\n";

    auto extruders {print.extruders()}; 
    _gcodegen.set_extruders(extruders.cbegin(), extruders.cend());
}

} // namespace Slic3r
#endif //SLIC3RXS
